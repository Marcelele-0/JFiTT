%{
/* ... (cała sekcja C bez zmian, z flagą calculated_something) ... */

#include <stdio.h>
#include <stdlib.h> 
#include <string.h> 
#include <math.h>   

#define MAX_STACK 256
long stack[MAX_STACK];
int stack_ptr = 0;

int error_on_line = 0;
char error_msg[100];
int calculated_something = 0; 

void reset_line_state() {
    stack_ptr = 0;
    error_on_line = 0;
    error_msg[0] = '\0';
    calculated_something = 0; 
}

void push(long val) {
    if (error_on_line) return;
    if (stack_ptr >= MAX_STACK) {
        error_on_line = 1;
        strcpy(error_msg, "Błąd: przepełnienie stosu (zbyt wiele liczb)");
    } else {
        stack[stack_ptr++] = val;
    }
}

long pop() {
    if (error_on_line) return 0;
    if (stack_ptr <= 0) {
        error_on_line = 1;
        strcpy(error_msg, "Błąd: za mała liczba argumentów");
        return 0;
    } else {
        return stack[--stack_ptr];
    }
}

%}

/* Opcje Flexa */
%option noyywrap 8bit

%%
    /* * SEKCJA REGUŁ
     * POPRAWKA: Zmieniamy kolejność i treść reguł,
     * aby operatory miały pierwszeństwo przed "chciwą" regułą liczby.
     */

[ \t]+              { /* 1. Ignoruj białe znaki */ }

    /* 2. Operatory (MUSZĄ BYĆ PRZED LICZBAMI) */
"+"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        push(op1 + op2);
                        calculated_something = 1; 
                    }
"-"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        push(op1 - op2);
                        calculated_something = 1; 
                    }
"*"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        push(op1 * op2);
                        calculated_something = 1; 
                    }
"/"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        if (op2 == 0) {
                            error_on_line = 1;
                            strcpy(error_msg, "Błąd: dzielenie przez zero");
                            break;
                        }
                        push(op1 / op2);
                        calculated_something = 1; 
                    }
"%"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        if (op2 == 0) {
                            error_on_line = 1;
                            strcpy(error_msg, "Błąd: modulo przez zero");
                            break;
                        }
                        push(op1 % op2);
                        calculated_something = 1; 
                    }
"^"                 {
                        if (error_on_line) break;
                        long op2_exponent = pop(); if (error_on_line) break;
                        long op1_base = pop(); if (error_on_line) break;
                        if (op2_exponent < 0) {
                            error_on_line = 1;
                            strcpy(error_msg, "Błąd: wykładnik ujemny (tylko l. całkowite)");
                            break;
                        }
                        push((long)pow((double)op1_base, (double)op2_exponent));
                        calculated_something = 1; 
                    }
                    
    /* 3. Liczby */
[0-9]+              {
                        /* Zwykła liczba dodatnia */
                        push(atol(yytext));
                    }
[-+][0-9]+          {
                        /* Liczba ze znakiem (np. -1, +5) */
                        /* Ta reguła jest oddzielna, ale nadal chciwa. */
                        /* To nic nie da. */
                        push(atol(yytext));
                    }
    
    /* ... \n i . bez zmian ... */
\n                  {
                        if (error_on_line) {
                            printf("%s\n", error_msg);
                        } else if (stack_ptr == 1) {
                            if (calculated_something) {
                                printf("= %ld\n", stack[0]);
                            } else {
                                printf("Błąd: za mała liczba operatorów\n");
                            }
                        } else if (stack_ptr > 1) {
                            printf("Błąd: za mała liczba operatorów\n");
                        } else {
                            ECHO;
                        }
                        reset_line_state();
                    }

.                   {
                        if (error_on_line) break; 
                        error_on_line = 1;
                        sprintf(error_msg, "Błąd: zły symbol \"%s\"", yytext);
                    }
%%

/* --- SEKCJA KODU UŻYTKOWNIKA (C) --- */

int main(int argc, char **argv) {
    yylex();
    return 0;
}