%{
/*
 * Plik Flex (zadanie4.l)
 *
 * Zadanie: Kalkulator RPN (postfix) dla liczb całkowitych.
 * Wersja 5 (Ostateczna) - Poprawnie obsługuje liczby ze znakiem
 * i operatory bez spacji, rozwiązując niejednoznaczność.
 */

#include <stdio.h>
#include <stdlib.h> // dla atol()
#include <string.h> // dla strcpy(), sprintf()
#include <math.h>   // dla pow()

/* --- Implementacja Stosu --- */
#define MAX_STACK 256
long stack[MAX_STACK];
int stack_ptr = 0;

/* --- Flagi błędów dla bieżącej linii --- */
int error_on_line = 0;
char error_msg[100];
int calculated_something = 0; 

/* Funkcja do resetowania stanu dla nowej linii */
void reset_line_state() {
    stack_ptr = 0;
    error_on_line = 0;
    error_msg[0] = '\0';
    calculated_something = 0; 
}

/* Funkcja pomocnicza: push na stos */
void push(long val) {
    if (error_on_line) return;

    if (stack_ptr >= MAX_STACK) {
        error_on_line = 1;
        strcpy(error_msg, "Błąd: przepełnienie stosu (zbyt wiele liczb)");
    } else {
        stack[stack_ptr++] = val;
    }
}

/* Funkcja pomocnicza: pop ze stosu */
long pop() {
    if (error_on_line) return 0;

    if (stack_ptr <= 0) {
        error_on_line = 1;
        strcpy(error_msg, "Błąd: za mała liczba argumentów");
        return 0;
    } else {
        return stack[--stack_ptr];
    }
}

%}

/* Opcje Flexa */
%option noyywrap 8bit

%%
    /* * SEKCJA REGUŁ
     * Rozwiązujemy niejednoznaczność "znak liczby" vs "operator"
     * poprzez zdefiniowanie liczb ze znakiem jako osobnych tokenów,
     * które MUSZĄ być na początku linii lub po spacji.
     */

    /* 1. Ignoruj puste spacje */
[ \t]+              { /* Ignoruj */ }


    /* 2. Reguły dla liczb (precyzyjne) */
    
    /* Liczba ze znakiem NA POCZĄTKU linii (np. "-1") */
^[-+][0-9]+         {
                        push(atol(yytext));
                    }
    
    /* Liczba ze znakiem POPRZEDZONA SPACJĄ (np. " 8 -7") */
    /* atol() sam zignoruje wiodącą spację w yytext */
[ \t]+[-+][0-9]+    {
                        push(atol(yytext));
                    }

    /* Zwykła liczba bez znaku (np. "2", "3", "4") */
[0-9]+              {
                        push(atol(yytext));
                    }

    /* 3. Reguły dla operatorów.
     * Ponieważ nie pasują już do "chciwych" reguł liczb,
     * zostaną poprawnie rozpoznane (np. "+" w "3+4").
     */
"+"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        push(op1 + op2);
                        calculated_something = 1; 
                    }
"-"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        push(op1 - op2);
                        calculated_something = 1; 
                    }
"*"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        push(op1 * op2);
                        calculated_something = 1; 
                    }
"/"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        if (op2 == 0) {
                            error_on_line = 1;
                            strcpy(error_msg, "Błąd: dzielenie przez zero");
                            break;
                        }
                        push(op1 / op2);
                        calculated_something = 1; 
                    }
"%"                 {
                        if (error_on_line) break;
                        long op2 = pop(); if (error_on_line) break;
                        long op1 = pop(); if (error_on_line) break;
                        if (op2 == 0) {
                            error_on_line = 1;
                            strcpy(error_msg, "Błąd: modulo przez zero");
                            break;
                        }
                        push(op1 % op2);
                        calculated_something = 1; 
                    }
"^"                 {
                        if (error_on_line) break;
                        long op2_exponent = pop(); if (error_on_line) break;
                        long op1_base = pop(); if (error_on_line) break;
                        if (op2_exponent < 0) {
                            error_on_line = 1;
                            strcpy(error_msg, "Błąd: wykładnik ujemny (tylko l. całkowite)");
                            break;
                        }
                        push((long)pow((double)op1_base, (double)op2_exponent));
                        calculated_something = 1; 
                    }

    /* 4. Koniec linii (czas na obliczenia) */
\n                  {
                        if (error_on_line) {
                            printf("%s\n", error_msg);
                        } else if (stack_ptr == 1) {
                            if (calculated_something) {
                                printf("= %ld\n", stack[0]);
                            } else {
                                printf("Błąd: za mała liczba operatorów\n");
                            }
                        } else if (stack_ptr > 1) {
                            printf("Błąd: za mała liczba operatorów\n");
                        } else {
                            ECHO; /* Pusta linia */
                        }
                        reset_line_state();
                    }

    /* 5. Zły symbol (wszystko inne) */
.                   {
                        if (error_on_line) break; 
                        error_on_line = 1;
                        sprintf(error_msg, "Błąd: zły symbol \"%s\"", yytext);
                    }
%%

/* --- SEKCJA KODU UŻYTKOWNIKA (C) --- */

int main(int argc, char **argv) {
    yylex();
    return 0;
}